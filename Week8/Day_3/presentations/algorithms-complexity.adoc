include::./_settings_deck.adoc[]
// include::../../../_settings_reveal.adoc[]

// beige, blond, default, moon, night, serif, simple, sky, solarized
// :revealjs_customtheme: reveal.js/css/theme/serif.css

== Algorithms


== What is an algorithm?

Basically: a recipe. But:

* Unambiguous specification
* Clearly defined input
* Always terminates
* Always gives back correct result

== Example: Find largest number
* **PROBLEM**: Given a list of positive numbers, find the largest one.
* **INPUT**: List `L` of positive numbers, with at least one number in it.
* **OUTPUT**: A number `n`, which is guaranteed to be the largest from `L`.
* **ALGORITHM**:
  1. Set `maxValue` to `0`.
  1. For each number `x` from list `L`
      - if `x` is larger than `maxValue` then replace `maxValue` with `x`.
  1. `maxValue` contains now the largest element from list `L`.


== Implementation

[source,javascript,numbered]
-------------------------------------------
function findMax(array, val) {
  var maxVal = 0;
  for (var x in array) {
    if (x > maxVal)
      maxVal = x;
  }
  return maxVal;
}
-------------------------------------------

== Complexity
* How long does it run?
* How much memory does it use?
* Device independent approximation
  * Measure `T(n)` in number of steps
  * Measure `M(n)` in number of entries 

== Example analysis
[source,javascript,numbered]
-------------------------------------------
function findMax(array, val) {
  var maxVal = 0;
  for (var x in array) {
    if (x > maxVal)
      maxVal = x;
  }
  return maxVal;
}
-------------------------------------------

== Same, but on algorithm?

* **ALGORITHM**:
  1. Set `maxValue` to `0`.
  1. For each number `x` from list `L`
      - if `x` is larger than `maxValue` then replace `maxValue` with `x`.
  1. `maxValue` contains now the largest element from list `L`.
  
== Count sum-pair in a list
    * **PROBLEM**: Given a list of numbers, and a sum. Count the number of
    pairs build from which have the given sum.
    * **INPUT**: List `L` of integer numbers, with at least one number in it. A number `S`
    * **OUTPUT**: A number `c`, which counts the number of pairs drawn from the list where the two components sum to `S`.
    
== Recursion
    * reduce problem to a smaller problem of the same kind
    * repeat until it can be solved trivially
    * use that solution solve the bigger problem
    
Most languages allow to call the current function from within itself.

== Recursion Examples
    * sum all numbers up to `k`
    * Fibonacci: 1 1 2 3 5 8 13...

== Big-O notation
* Worst case analysis
* Approximation
    - `O(1)`: contant  
    - `O(log n)`: logarithmic
    - `O(n)`: linear 
    - `O(n log n)`: quasiliner 
    - `O(n^2)`: quadratic 
    - `O(n^3)`, `O(n^4)`, ...: polynomial   
    - `O(2^n)`: exponential complexity.

== Big-O visualized

image::https://www.daveperrett.com/images/articles/2010-12-07-comp-sci-101-big-o-notation/Time_Complexity.png[,80%]



